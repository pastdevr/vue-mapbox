!(function(e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? t(
        exports,
        require("@babel/runtime/helpers/defineProperty"),
        require("vue"),
        require("@babel/runtime/helpers/typeof")
      )
    : "function" == typeof define && define.amd
    ? define([
        "exports",
        "@babel/runtime/helpers/defineProperty",
        "vue",
        "@babel/runtime/helpers/typeof"
      ], t)
    : t(
        ((e = "undefined" != typeof globalThis ? globalThis : e || self)[
          "vue-mapbox"
        ] = {}),
        e._defineProperty,
        e.vue,
        e._typeof
      );
})(this, function(e, t, r, n) {
  "use strict";
  function o(e) {
    return e && "object" == typeof e && "default" in e ? e : { default: e };
  }
  var i = o(t),
    a = o(n);
  function s(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function c(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? s(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : s(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var u = {
      methods: {
        $_emitEvent: function(e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.$emit(e, c({ map: this.map, component: this }, t));
        },
        $_emitMapEvent: function(e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.$_emitEvent(e.type, c({ mapboxEvent: e }, t));
        }
      }
    },
    p = {
      resize: { name: "resize" },
      webglcontextlost: { name: "webglcontextlost" },
      webglcontextrestored: { name: "webglcontextrestored" },
      remove: { name: "remove" },
      movestart: { name: "movestart" },
      load: { name: "load" },
      contextmenu: { name: "contextmenu" },
      dblclick: { name: "dblclick" },
      click: { name: "click" },
      touchcancel: { name: "touchcancel" },
      touchmove: { name: "touchmove" },
      touchend: { name: "touchend" },
      touchstart: { name: "touchstart" },
      dataloading: { name: "dataloading" },
      mousemove: { name: "mousemove" },
      mouseup: { name: "mouseup" },
      mousedown: { name: "mousedown" },
      sourcedataloading: { name: "sourcedataloading" },
      error: { name: "error" },
      data: { name: "data" },
      styledata: { name: "styledata" },
      sourcedata: { name: "sourcedata" },
      mouseout: { name: "mouseout" },
      styledataloading: { name: "styledataloading" },
      moveend: { name: "moveend" },
      move: { name: "move" },
      render: { name: "render" },
      zoom: { name: "zoom" },
      zoomstart: { name: "zoomstart" },
      zoomend: { name: "zoomend" },
      boxzoomstart: { name: "boxzoomstart" },
      boxzoomcancel: { name: "boxzoomcancel" },
      boxzoomend: { name: "boxzoomend" },
      rotate: { name: "rotate" },
      rotatestart: { name: "rotatestart" },
      rotateend: { name: "rotateend" },
      dragend: { name: "dragend" },
      drag: { name: "drag" },
      dragstart: { name: "dragstart" },
      pitch: { name: "pitch" },
      idle: { name: "idle" }
    },
    l = {
      container: {
        type: [String, HTMLElement],
        default: function() {
          return "map-".concat(("" + Math.random()).split(".")[1]);
        }
      },
      accessToken: { type: String, default: void 0 },
      minZoom: { type: Number, default: 0 },
      maxZoom: { type: Number, default: 22 },
      mapStyle: { type: [String, Object], required: !0 },
      hash: { type: [Boolean, String], default: !1 },
      interactive: { type: Boolean, default: !0 },
      bearingSnap: { type: Number, default: 7 },
      pitchWithRotate: { type: Boolean, default: !0 },
      clickTolerance: { type: Number, default: 3 },
      attributionControl: { type: Boolean, default: !0 },
      customAttribution: { type: [String, Array], default: null },
      logoPosition: {
        type: String,
        default: "bottom-left",
        validator: function(e) {
          return [
            "top-left",
            "top-right",
            "bottom-left",
            "bottom-right"
          ].includes(e);
        }
      },
      failIfMajorPerformanceCaveat: { type: Boolean, default: !1 },
      preserveDrawingBuffer: { type: Boolean, default: !1 },
      refreshExpiredTiles: { type: Boolean, default: !0 },
      maxBounds: { type: Array, default: function() {} },
      scrollZoom: {
        type: [Boolean, Object],
        default: function() {
          return !0;
        }
      },
      boxZoom: { type: Boolean, default: !0 },
      dragRotate: { type: Boolean, default: !0 },
      dragPan: { type: Boolean, default: !0 },
      keyboard: { type: Boolean, default: !0 },
      doubleClickZoom: { type: Boolean, default: !0 },
      touchZoomRotate: {
        type: [Boolean, Object],
        default: function() {
          return !0;
        }
      },
      trackResize: { type: Boolean, default: !0 },
      center: { type: [Object, Array], default: void 0 },
      zoom: { type: Number, default: 0 },
      bearing: { type: Number, default: 0 },
      pitch: { type: Number, default: 0 },
      bounds: { type: [Object, Array], default: void 0 },
      fitBoundsOptions: { type: Object, default: void 0 },
      renderWorldCopies: { type: Boolean, default: !0 },
      RTLTextPluginUrl: { type: String, default: void 0 },
      light: { type: Object, default: void 0 },
      tileBoundaries: { type: Boolean, default: !1 },
      collisionBoxes: { type: Boolean, default: !1 },
      repaint: { type: Boolean, default: !1 },
      transformRequest: { type: Function, default: null },
      maxTileCacheSize: { type: Number, default: null },
      localIdeographFontFamily: { type: String, default: null },
      collectResourceTiming: { type: Boolean, default: !1 },
      fadeDuration: { type: Number, default: 300 },
      crossSourceCollisions: { type: Boolean, default: !0 }
    },
    d = function(e) {
      var t = /^on[^a-z]/,
        r = {};
      for (var n in e) t.test(n) && (r[n] = e[n]);
      return r;
    },
    h = {
      maxBounds: function(e) {
        this.map.setMaxBounds(e);
      },
      minZoom: function(e) {
        this.map.setMinZoom(e);
      },
      maxZoom: function(e) {
        this.map.setMaxZoom(e);
      },
      mapStyle: function(e) {
        this.map.setStyle(e);
      },
      collisionBoxes: function(e) {
        this.map.showCollisionBoxes = e;
      },
      tileBoundaries: function(e) {
        this.map.showTileBoundaries = e;
      },
      repaint: function(e) {
        this.map.repaint = e;
      },
      zoom: function(e) {
        this.map.setZoom(e);
      },
      center: function(e) {
        this.map.setCenter(e);
      },
      bearing: function(e) {
        this.map.setBearing(e);
      },
      pitch: function(e) {
        this.map.setPitch(e);
      },
      light: function(e) {
        this.map.setLigh(e);
      }
    };
  function f(e, t, r, n) {
    var o = this;
    this.initial ||
      (d(this.$attrs)["update:".concat(e)]
        ? (this.propsIsUpdating[e]
            ? ((this._watcher.active = !1),
              this.$nextTick(function() {
                o._watcher.active = !0;
              }))
            : ((this._watcher.active = !0), t(r, n)),
          (this.propsIsUpdating[e] = !1))
        : t(r, n));
  }
  var m,
    y = {
      watch:
        ((m = {}),
        Object.entries(h).forEach(function(e) {
          m[e[0]] = function(t, r) {
            return f.call(this, e[0], e[1].bind(this), t, r);
          };
        }),
        m)
    };
  function b(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function v(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? b(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : b(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var g = {
    methods: {
      $_updateSyncedPropsFabric: function(e, t) {
        var r = this;
        return function() {
          r.propsIsUpdating[e] = !0;
          var n = "function" == typeof t ? t() : t;
          return r.$emit("update:".concat(e), n);
        };
      },
      $_bindPropsUpdateEvents: function() {
        var e = this,
          t = [
            {
              events: ["moveend"],
              prop: "center",
              getter: this.map.getCenter.bind(this.map)
            },
            {
              events: ["zoomend"],
              prop: "zoom",
              getter: this.map.getZoom.bind(this.map)
            },
            {
              events: ["rotate"],
              prop: "bearing",
              getter: this.map.getBearing.bind(this.map)
            },
            {
              events: ["pitch"],
              prop: "pitch",
              getter: this.map.getPitch.bind(this.map)
            },
            {
              events: ["moveend", "zoomend", "rotate", "pitch"],
              prop: "bounds",
              getter: function() {
                var t = e.map.getBounds();
                return e.$props.bounds instanceof Array && (t = t.toArray()), t;
              }
            }
          ],
          r = d(this.$attrs);
        t.forEach(function(t) {
          var n = t.events,
            o = t.prop,
            i = t.getter;
          n.forEach(function(t) {
            r["update:".concat(o)] &&
              e.map.on(t, e.$_updateSyncedPropsFabric(o, i));
          });
        });
      },
      $_loadMap: function() {
        var e = this;
        return this.mapboxPromise.then(function(t) {
          return (
            (e.mapbox = t.default ? t.default : t),
            new Promise(function(t) {
              e.accessToken && (e.mapbox.accessToken = e.accessToken);
              var r = new e.mapbox.Map(
                v(
                  v({}, e._props),
                  {},
                  { container: e.$refs.container, style: e.mapStyle }
                )
              );
              r.on("load", function() {
                return t(r);
              });
            })
          );
        });
      },
      $_RTLTextPluginError: function(e) {
        this.$emit("rtl-plugin-error", { map: this.map, error: e });
      },
      $_bindMapEvents: function(e) {
        var t = this,
          r = d(this.$attrs);
        Object.keys(r).forEach(function(r) {
          e.includes(r) && t.map.on(r, t.$_emitMapEvent);
        });
      },
      $_unbindEvents: function(e) {
        var t = this;
        e.forEach(function(e) {
          t.map.off(e, t.$_emitMapEvent);
        });
      }
    }
  };
  function O(e) {
    return e &&
      e.__esModule &&
      Object.prototype.hasOwnProperty.call(e, "default")
      ? e.default
      : e;
  }
  var j = { exports: {} };
  !(function(e, t) {
    window,
      (e.exports = (function(e) {
        var t = {};
        function r(n) {
          if (t[n]) return t[n].exports;
          var o = (t[n] = { i: n, l: !1, exports: {} });
          return e[n].call(o.exports, o, o.exports, r), (o.l = !0), o.exports;
        }
        return (
          (r.m = e),
          (r.c = t),
          (r.d = function(e, t, n) {
            r.o(e, t) ||
              Object.defineProperty(e, t, { enumerable: !0, get: n });
          }),
          (r.r = function(e) {
            "undefined" != typeof Symbol &&
              Symbol.toStringTag &&
              Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
              Object.defineProperty(e, "__esModule", { value: !0 });
          }),
          (r.t = function(e, t) {
            if ((1 & t && (e = r(e)), 8 & t)) return e;
            if (4 & t && "object" === a.default(e) && e && e.__esModule)
              return e;
            var n = Object.create(null);
            if (
              (r.r(n),
              Object.defineProperty(n, "default", { enumerable: !0, value: e }),
              2 & t && "string" != typeof e)
            )
              for (var o in e)
                r.d(
                  n,
                  o,
                  function(t) {
                    return e[t];
                  }.bind(null, o)
                );
            return n;
          }),
          (r.n = function(e) {
            var t =
              e && e.__esModule
                ? function() {
                    return e.default;
                  }
                : function() {
                    return e;
                  };
            return r.d(t, "a", t), t;
          }),
          (r.o = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
          }),
          (r.p = ""),
          r((r.s = 0))
        );
      })([
        function(e, t, r) {
          e.exports = r(1);
        },
        function(e, t, r) {
          r.r(t);
          var n = {
              events: [
                {
                  name: "moveend",
                  check: function(e, t) {
                    return t.center && e.isMoving();
                  }
                },
                {
                  name: "zoomend",
                  check: function(e, t) {
                    return (
                      void 0 !== t.zoom && null !== t.zoom && e.isZooming()
                    );
                  }
                },
                {
                  name: "rotateend",
                  check: function(e, t) {
                    return (
                      void 0 !== t.bearing &&
                      null !== t.bearing &&
                      e.isRotating()
                    );
                  }
                },
                {
                  name: "pitchend",
                  check: function(e, t) {
                    return (
                      void 0 !== t.pitch && null !== t.bearing && e.isMoving()
                    );
                  }
                }
              ],
              getter: function(e) {
                return {
                  center: e.getCenter(),
                  zoom: e.getZoom(),
                  bearing: e.getBearing(),
                  pitch: e.getPitch()
                };
              }
            },
            o = {
              events: [
                {
                  name: "moveend",
                  check: function(e) {
                    return e.isMoving();
                  }
                }
              ],
              getter: function(e) {
                return { center: e.getCenter() };
              }
            },
            i = {
              events: [
                {
                  name: "zoomend",
                  check: function(e) {
                    return e.isZooming();
                  }
                }
              ],
              getter: function(e) {
                return { zoom: e.getZoom() };
              }
            },
            s = {
              events: [
                {
                  name: "rotateend",
                  check: function(e) {
                    return e.isRotating();
                  }
                }
              ],
              getter: function(e) {
                return { bearing: e.getBearing() };
              }
            },
            c = {
              setCenter: o,
              panBy: o,
              panTo: o,
              setZoom: i,
              zoomTo: i,
              zoomIn: i,
              zoomOut: i,
              setBearing: s,
              rotateTo: s,
              resetNorth: s,
              snapToNorth: s,
              setPitch: {
                events: [
                  {
                    name: "pitchend",
                    check: function(e) {
                      return !0;
                    }
                  }
                ],
                getter: function(e) {
                  return { pitch: e.getPitch() };
                }
              },
              fitBounds: {
                events: [
                  {
                    name: "zoomend",
                    check: function(e) {
                      return e.isZooming();
                    }
                  },
                  {
                    name: "moveend",
                    check: function(e) {
                      return e.isMoving();
                    }
                  },
                  {
                    name: "rotateend",
                    check: function(e) {
                      return e.isRotating();
                    }
                  }
                ],
                getter: function(e) {
                  return {
                    zoom: e.getZoom(),
                    bearing: e.getBearing(),
                    pitch: e.getPitch(),
                    center: e.getCenter()
                  };
                }
              },
              fitScreenCoordinates: {
                events: [
                  {
                    name: "zoomend",
                    check: function(e, t) {
                      return e.isZooming();
                    }
                  },
                  {
                    name: "moveend",
                    check: function(e, t) {
                      return e.isMoving();
                    }
                  },
                  {
                    name: "rotateend",
                    check: function(e, t) {
                      return t.bearing && e.isRotating();
                    }
                  }
                ],
                getter: function(e) {
                  return {
                    zoom: e.getZoom(),
                    center: e.getCenter(),
                    bearing: e.getBearing(),
                    pitch: e.getPitch()
                  };
                }
              },
              jumpTo: n,
              easeTo: n,
              flyTo: n
            };
          function u(e) {
            return (u =
              "function" == typeof Symbol &&
              "symbol" === a.default(Symbol.iterator)
                ? function(e) {
                    return a.default(e);
                  }
                : function(e) {
                    return e &&
                      "function" == typeof Symbol &&
                      e.constructor === Symbol &&
                      e !== Symbol.prototype
                      ? "symbol"
                      : a.default(e);
                  })(e);
          }
          function p(e) {
            for (var t = 1; t < arguments.length; t++) {
              var r = null != arguments[t] ? arguments[t] : {},
                n = Object.keys(r);
              "function" == typeof Object.getOwnPropertySymbols &&
                (n = n.concat(
                  Object.getOwnPropertySymbols(r).filter(function(e) {
                    return Object.getOwnPropertyDescriptor(r, e).enumerable;
                  })
                )),
                n.forEach(function(t) {
                  l(e, t, r[t]);
                });
            }
            return e;
          }
          function l(e, t, r) {
            return (
              t in e
                ? Object.defineProperty(e, t, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                  })
                : (e[t] = r),
              e
            );
          }
          function d(e) {
            return "".concat(e, "-").concat(("" + Math.random()).split(".")[1]);
          }
          function h(e, t, r, n) {
            return function o(i) {
              i.type === t && i.eventId === r && (e.off(t, o), n(i));
            };
          }
          function f(e, t) {
            var r = e[t],
              n = r.length;
            return function() {
              for (
                var o = [],
                  i = { eventId: d(t) },
                  a = c[t].events.map(function(t, r) {
                    return {
                      event: t,
                      func: new Promise(function(n, a) {
                        (o[r] = { event: t, func: h(e, t.name, i.eventId, n) }),
                          e.on(t.name, o[r].func);
                      })
                    };
                  }),
                  s = [],
                  l = 0;
                l < n;
                l++
              )
                l === n - 1
                  ? s.push(
                      p(
                        {},
                        i,
                        (l < 0 || arguments.length <= l
                          ? void 0
                          : arguments[l]) || {}
                      )
                    )
                  : s.push(
                      (l < 0 || arguments.length <= l
                        ? void 0
                        : arguments[l]) || null
                    );
              var f = [],
                m = (arguments.length <= 0 ? void 0 : arguments[0]) || {};
              try {
                r.apply(e, s),
                  "fitBounds" === t && (m = {}),
                  "fitScreenCoordinates" === t &&
                    (((m = { bearing: null }).bearing = null),
                    "number" ==
                      typeof (arguments.length <= 2 ? void 0 : arguments[2]) &&
                      (m.bearing =
                        arguments.length <= 2 ? void 0 : arguments[2]),
                    (arguments.length <= 3 ? void 0 : arguments[3]) &&
                      "object" ===
                        u(arguments.length <= 3 ? void 0 : arguments[3]) &&
                      (m = p(
                        {},
                        m,
                        arguments.length <= 3 ? void 0 : arguments[3]
                      ))),
                  (f = a.map(function(t) {
                    var r = t.event,
                      n = t.func;
                    return r.check(e, m)
                      ? n
                      : (e.off(r.name, n), Promise.resolve());
                  }));
              } catch (t) {
                throw (o.forEach(function(t) {
                  var r = t.event,
                    n = t.func;
                  e.off(r.name, n);
                }),
                t);
              }
              return Promise.all(f).then(function() {
                return c[t].getter(e);
              });
            };
          }
          var m = f,
            y = function(e) {
              var t = Object.keys(c),
                r = {};
              return (
                t.forEach(function(n) {
                  -1 !== t.indexOf(n) && (r[n] = m(e, n));
                }),
                r
              );
            };
          function b(e) {
            var t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : null;
            return t ? m(e, t) : y(e);
          }
          r.d(t, "default", function() {
            return b;
          });
        }
      ]).default);
  })(j);
  var $ = O(j.exports);
  function P(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function w(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? P(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : P(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function S(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  var _ = {
    name: "GlMap",
    mixins: [
      y,
      {
        created: function() {
          this.actions = {};
        },
        methods: {
          $_registerAsyncActions: function(e) {
            this.actions = w(
              w({}, $(e)),
              {},
              {
                stop: function() {
                  var e = this;
                  this.map.stop();
                  var t = {
                    pitch: this.map.getPitch(),
                    zoom: this.map.getZoom(),
                    bearing: this.map.getBearing(),
                    center: this.map.getCenter()
                  };
                  return (
                    Object.entries(t).forEach(function(t) {
                      e.$_updateSyncedPropsFabric(t[0], t[1])();
                    }),
                    Promise.resolve(t)
                  );
                }
              }
            );
          }
        }
      },
      g,
      u
    ],
    props: (function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var r = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? S(Object(r), !0).forEach(function(t) {
              i.default(e, t, r[t]);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : S(Object(r)).forEach(function(t) {
              Object.defineProperty(
                e,
                t,
                Object.getOwnPropertyDescriptor(r, t)
              );
            });
      }
      return e;
    })({ mapboxGl: { type: Object, default: null } }, l),
    provide: function() {
      var e = this;
      return {
        get mapbox() {
          return e.mapbox;
        },
        get map() {
          return e.map;
        },
        get actions() {
          return e.actions;
        }
      };
    },
    data: function() {
      return { initial: !0, initialized: !1 };
    },
    computed: {
      loaded: function() {
        return !!this.map && this.map.loaded();
      },
      version: function() {
        return this.map ? this.map.version : null;
      },
      isStyleLoaded: function() {
        return !!this.map && this.map.isStyleLoaded();
      },
      areTilesLoaded: function() {
        return !!this.map && this.map.areTilesLoaded();
      },
      isMoving: function() {
        return !!this.map && this.map.isMoving();
      },
      canvas: function() {
        return this.map ? this.map.getCanvas() : null;
      },
      canvasContainer: function() {
        return this.map ? this.map.getCanvasContainer() : null;
      },
      images: function() {
        return this.map ? this.map.listImages() : null;
      }
    },
    created: function() {
      (this.map = null),
        (this.propsIsUpdating = {}),
        (this.$_containerVNode = null),
        (this.mapboxPromise = this.mapboxGl
          ? Promise.resolve(this.mapboxGl)
          : import("mapbox-gl"));
    },
    mounted: function() {
      var e = this;
      this.$_loadMap().then(function(t) {
        (e.map = t),
          void 0 !== e.RTLTextPluginUrl &&
            "loaded" !== e.mapbox.getRTLTextPluginStatus() &&
            e.mapbox.setRTLTextPlugin(
              e.RTLTextPluginUrl,
              e.$_RTLTextPluginError
            );
        var r = Object.keys(p);
        e.$_bindMapEvents(r),
          e.$_registerAsyncActions(t),
          e.$_bindPropsUpdateEvents(),
          (e.initial = !1),
          (e.initialized = !0),
          e.$emit("load", { map: t, component: e });
      });
    },
    beforeDestroy: function() {
      var e = this;
      this.$nextTick(function() {
        e.map && e.map.remove();
      });
    },
    render: function() {
      return (
        this.$$_containerVNode ||
          (this.$_containerVNode = r.h("div", {
            id: this.container,
            ref: "container"
          })),
        r.h("div", { class: "mgl-map-wrapper" }, [
          this.$_containerVNode,
          this.initialized ? this.$slots.default : null
        ])
      );
    }
  };
  function I(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function E(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? I(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : I(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var x = {
      methods: {
        $_emitSelfEvent: function(e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.$_emitMapEvent(e, E({ control: this.control }, t));
        },
        $_bindSelfEvents: function(e, t) {
          var r = this,
            n = d(this.$attrs);
          Object.keys(n).forEach(function(n) {
            e.includes(n) && t.on(n, r.$_emitSelfEvent);
          });
        },
        $_unbindSelfEvents: function(e, t) {
          var r = this;
          0 !== e.length &&
            t &&
            e.forEach(function(e) {
              t.off(e, r.$_emitSelfEvent);
            });
        }
      }
    },
    L = {
      mixins: [u, x],
      inject: ["mapbox", "map", "actions"],
      props: { position: { type: String, default: "top-right" } },
      beforeDestroy: function() {
        this.map && this.control && this.map.removeControl(this.control);
      },
      methods: {
        $_addControl: function() {
          try {
            this.map.addControl(this.control, this.position);
          } catch (e) {
            return void this.$_emitEvent("error", { error: e });
          }
          this.$_emitEvent("added", { control: this.control });
        }
      },
      render: function() {}
    },
    k = {
      name: "NavigationControl",
      mixins: [L],
      props: {
        showCompass: { type: Boolean, default: !0 },
        showZoom: { type: Boolean, default: !0 }
      },
      created: function() {
        (this.control = new this.mapbox.NavigationControl(this.$props)),
          this.$_addControl();
      }
    },
    M = {
      trackuserlocationstart: "trackuserlocationstart",
      trackuserlocationend: "trackuserlocationend",
      geolocate: "geolocate",
      error: "error"
    },
    D = {
      name: "GeolocateControl",
      mixins: [u, x, L],
      props: {
        positionOptions: {
          type: Object,
          default: function() {
            return { enableHighAccuracy: !1, timeout: 6e3 };
          }
        },
        fitBoundsOptions: {
          type: Object,
          default: function() {
            return { maxZoom: 15 };
          }
        },
        trackUserLocation: { type: Boolean, default: !1 },
        showUserLocation: { type: Boolean, default: !0 }
      },
      created: function() {
        var e = this.mapbox.GeolocateControl;
        (this.control = new e(this.$props)),
          this.$_addControl(),
          this.$_bindSelfEvents(Object.keys(M), this.control);
      },
      methods: {
        trigger: function() {
          if (this.control) return this.control.trigger();
        }
      }
    },
    C = {
      name: "FullscreenControl",
      mixins: [L],
      props: { container: { type: HTMLElement, default: void 0 } },
      created: function() {
        (this.control = new this.mapbox.FullscreenControl(this.$props)),
          this.$_addControl();
      }
    },
    B = {
      name: "AttributionControl",
      mixins: [L],
      props: {
        compact: { type: Boolean, default: !0 },
        customAttribution: { type: [String, Array], deafault: void 0 }
      },
      created: function() {
        (this.control = new this.mapbox.AttributionControl(this.$props)),
          this.$_addControl();
      }
    },
    T = {
      name: "ScaleControl",
      mixins: [L],
      props: {
        maxWidth: { type: Number, default: 150 },
        unit: {
          type: String,
          default: "metric",
          validator: function(e) {
            return ["imperial", "metric", "nautical"].includes(e);
          }
        }
      },
      watch: {
        unit: function(e, t) {
          this.control && e !== t && this.control.setUnit(e);
        }
      },
      created: function() {
        (this.control = new this.mapbox.ScaleControl(this.$props)),
          this.$_addControl();
      }
    };
  function z(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  var F = { drag: "drag", dragstart: "dragstart", dragend: "dragend" },
    Z = { click: "click", mouseenter: "mouseenter", mouseleave: "mouseleave" },
    R = {
      name: "MapMarker",
      mixins: [u, x],
      inject: ["mapbox", "map"],
      provide: function() {
        var e = this;
        return {
          get marker() {
            return e.marker;
          }
        };
      },
      props: {
        offset: {
          type: [Object, Array],
          default: function() {
            return [0, 0];
          }
        },
        coordinates: { type: Array, required: !0 },
        color: { type: String },
        anchor: { type: String, default: "center" },
        draggable: { type: Boolean, default: !1 }
      },
      data: function() {
        return { initial: !0, marker: void 0 };
      },
      watch: {
        coordinates: function(e) {
          this.initial || this.marker.setLngLat(e);
        },
        draggable: function(e) {
          this.initial || this.marker.setDraggable(e);
        }
      },
      mounted: function() {
        var e = this,
          t = (function(e) {
            for (var t = 1; t < arguments.length; t++) {
              var r = null != arguments[t] ? arguments[t] : {};
              t % 2
                ? z(Object(r), !0).forEach(function(t) {
                    i.default(e, t, r[t]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    e,
                    Object.getOwnPropertyDescriptors(r)
                  )
                : z(Object(r)).forEach(function(t) {
                    Object.defineProperty(
                      e,
                      t,
                      Object.getOwnPropertyDescriptor(r, t)
                    );
                  });
            }
            return e;
          })({}, this.$props);
        this.$slots.marker && (t.element = this.$slots.marker[0].elm),
          (this.marker = new this.mapbox.Marker(t)),
          d(this.$attrs)["update:coordinates"] &&
            this.marker.on("dragend", function(t) {
              var r;
              (r =
                e.coordinates instanceof Array
                  ? [t.target._lngLat.lng, t.target._lngLat.lat]
                  : t.target._lngLat),
                e.$emit("update:coordinates", r);
            });
        var r = Object.keys(F);
        this.$_bindSelfEvents(r, this.marker),
          (this.initial = !1),
          this.$_addMarker();
      },
      beforeDestroy: function() {
        void 0 !== this.map && void 0 !== this.marker && this.marker.remove();
      },
      methods: {
        $_addMarker: function() {
          this.marker.setLngLat(this.coordinates).addTo(this.map),
            this.$_bindMarkerDOMEvents(),
            this.$_emitEvent("added", { marker: this.marker });
        },
        $_emitSelfEvent: function(e) {
          this.$_emitMapEvent(e, { marker: this.marker });
        },
        $_bindMarkerDOMEvents: function() {
          var e = this,
            t = d(this.$attrs);
          Object.keys(t).forEach(function(t) {
            Object.values(Z).includes(t) &&
              e.marker._element.addEventListener(t, function(t) {
                e.$_emitSelfEvent(t);
              });
          });
        },
        remove: function() {
          this.marker.remove(), this.$_emitEvent("removed");
        },
        togglePopup: function() {
          return this.marker.togglePopup();
        }
      },
      render: function() {
        return r.h("div", { style: { display: "none" } }, [
          this.$slots.marker,
          this.marker ? this.$slots.default : null
        ]);
      }
    },
    A = { open: "open", close: "close" },
    N = {
      name: "Popup",
      mixins: [u, x],
      inject: {
        mapbox: { default: null },
        map: { default: null },
        marker: { default: null }
      },
      props: {
        closeButton: { type: Boolean, default: !0 },
        closeOnClick: { type: Boolean, default: !0 },
        anchor: {
          validator: function(e) {
            return (
              "string" == typeof e &&
              [
                "top",
                "bottom",
                "left",
                "right",
                "top-left",
                "top-right",
                "bottom-left",
                "bottom-right"
              ].includes(e)
            );
          },
          default: void 0
        },
        offset: {
          type: [Number, Object, Array],
          default: function() {
            return [0, 0];
          }
        },
        coordinates: { type: Array },
        onlyText: { type: Boolean, default: !1 },
        showed: { type: Boolean, default: !1 }
      },
      data: function() {
        return { initial: !0, popup: void 0 };
      },
      computed: {
        open: {
          get: function() {
            return void 0 !== this.popup && this.popup.isOpen();
          },
          set: function(e) {
            this.map &&
              this.popup &&
              (e ? this.popup.addTo(this.map) : this.popup.remove());
          }
        }
      },
      watch: {
        coordinates: function(e) {
          this.initial || this.popup.setLngLat(e);
        },
        showed: function(e, t) {
          e !== t &&
            ((this.open = e), this.marker && this.marker.togglePopup());
        }
      },
      created: function() {
        this.popup = new this.mapbox.Popup(this.$props);
      },
      mounted: function() {
        this.$_addPopup(), (this.initial = !1);
      },
      beforeDestroy: function() {
        this.map && (this.popup.remove(), this.$_emitEvent("removed"));
      },
      methods: {
        $_addPopup: function() {
          if (
            ((this.popup = new this.mapbox.Popup(this.$props)),
            void 0 !== this.coordinates &&
              this.popup.setLngLat(this.coordinates),
            void 0 !== this.$slots.default)
          )
            if (this.onlyText)
              if (3 === this.$slots.default[0].elm.nodeType) {
                var e = document.createElement("span");
                e.appendChild(this.$slots.default[0].elm),
                  this.popup.setText(e.innerText);
              } else this.popup.setText(this.$slots.default[0].elm.innerText);
            else this.popup.setDOMContent(this.$slots.default[0].elm);
          this.$_bindSelfEvents(Object.keys(A), this.popup),
            this.$_emitEvent("added", { popup: this.popup }),
            this.marker && this.marker.setPopup(this.popup),
            this.showed &&
              ((this.open = !0), this.marker && this.marker.togglePopup());
        },
        $_emitSelfEvent: function(e) {
          this.$_emitMapEvent(e, { popup: this.popup });
        },
        remove: function() {
          this.popup.remove(),
            this.$_emitEvent("remove", { popup: this.popup });
        }
      },
      render: function() {
        return r.h("div", { style: { display: "none" } }, [
          this.$slots.default
        ]);
      }
    },
    q = [
      "mousedown",
      "mouseup",
      "click",
      "dblclick",
      "mousemove",
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "contextmenu",
      "touchstart",
      "touchend",
      "touchcancel"
    ];
  function U(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function G(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? U(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : U(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var V = {
      layerId: { type: String, required: !0 },
      layer: { type: Object, required: !0 },
      before: { type: String, default: void 0 }
    },
    H = {
      clearSource: { type: Boolean, default: !0 },
      replaceSource: { type: Boolean, default: !1 },
      replace: { type: Boolean, default: !1 }
    },
    W = {
      mixins: [u],
      props: G(
        G(
          G(
            {},
            {
              sourceId: { type: String, required: !0 },
              source: { type: [Object, String], default: void 0 }
            }
          ),
          V
        ),
        H
      ),
      inject: ["mapbox", "map"],
      data: function() {
        return { initial: !0 };
      },
      computed: {
        sourceLoaded: function() {
          return !!this.map && this.map.isSourceLoaded(this.sourceId);
        },
        mapLayer: function() {
          return this.map ? this.map.getLayer(this.layerId) : null;
        },
        mapSource: function() {
          return this.map ? this.map.getSource(this.sourceId) : null;
        }
      },
      created: function() {
        this.layer.minzoom &&
          this.$watch("layer.minzoom", function(e) {
            this.initial ||
              this.map.setLayerZoomRange(this.layerId, e, this.layer.maxzoom);
          }),
          this.layer.maxzoom &&
            this.$watch("layer.maxzoom", function(e) {
              this.initial ||
                this.map.setLayerZoomRange(this.layerId, this.layer.minzoom, e);
            }),
          this.layer.paint &&
            this.$watch(
              "layer.paint",
              function(e) {
                if (!this.initial && e)
                  for (var t = 0, r = Object.keys(e); t < r.length; t++) {
                    var n = r[t];
                    this.map.setPaintProperty(this.layerId, n, e[n]);
                  }
              },
              { deep: !0 }
            ),
          this.layer.layout &&
            this.$watch(
              "layer.layout",
              function(e) {
                if (!this.initial && e)
                  for (var t = 0, r = Object.keys(e); t < r.length; t++) {
                    var n = r[t];
                    this.map.setLayoutProperty(this.layerId, n, e[n]);
                  }
              },
              { deep: !0 }
            ),
          this.layer.filter &&
            this.$watch(
              "layer.filter",
              function(e) {
                this.initial || this.map.setFilter(this.layerId, e);
              },
              { deep: !0 }
            );
      },
      beforeDestroy: function() {
        if (this.map && this.map.loaded()) {
          try {
            this.map.removeLayer(this.layerId);
          } catch (e) {
            this.$_emitEvent("layer-does-not-exist", {
              layerId: this.sourceId,
              error: e
            });
          }
          if (this.clearSource)
            try {
              this.map.removeSource(this.sourceId);
            } catch (e) {
              this.$_emitEvent("source-does-not-exist", {
                sourceId: this.sourceId,
                error: e
              });
            }
        }
      },
      methods: {
        $_emitLayerMapEvent: function(e) {
          return this.$_emitMapEvent(e, { layerId: this.layerId });
        },
        $_bindLayerEvents: function(e) {
          var t = this,
            r = d(this.$attrs);
          Object.keys(r).forEach(function(r) {
            e.includes(r) && t.map.on(r, t.layerId, t.$_emitLayerMapEvent);
          });
        },
        $_unbindEvents: function(e) {
          var t = this;
          this.map &&
            e.forEach(function(e) {
              t.map.off(e, t.layerId, t.$_emitLayerMapEvent);
            });
        },
        $_watchSourceLoading: function(e) {
          "source" === e.dataType &&
            e.sourceId === this.sourceId &&
            (this.$_emitEvent("layer-source-loading", {
              sourceId: this.sourceId
            }),
            this.map.off("dataloading", this.$_watchSourceLoading));
        },
        move: function(e) {
          this.map.moveLayer(this.layerId, e),
            this.$_emitEvent("layer-moved", {
              layerId: this.layerId,
              beforeId: e
            });
        },
        remove: function() {
          this.map.removeLayer(this.layerId),
            this.map.removeSource(this.sourceId),
            this.$_emitEvent("layer-removed", { layerId: this.layerId }),
            this.$destroy();
        }
      },
      render: function() {}
    };
  function J(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function K(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? J(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : J(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function Q(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function X(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? Q(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : Q(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function Y(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function ee(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? Y(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : Y(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function te(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function re(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? te(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : te(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function ne(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function oe(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? ne(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : ne(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function ie(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function ae(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? ie(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : ie(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var se = u,
    ce = x,
    ue = L,
    pe = W,
    le = { withEvents: u, withSelfEvents: x, asControl: L, asLayer: W },
    de = _,
    he = k,
    fe = D,
    me = C,
    ye = B,
    be = T,
    ve = {
      name: "GeojsonLayer",
      mixins: [W],
      computed: {
        getSourceFeatures: function() {
          var e = this;
          return function(t) {
            return e.map
              ? e.map.querySourceFeatures(e.sourceId, { filter: t })
              : null;
          };
        },
        getRenderedFeatures: function() {
          var e = this;
          return function(t, r) {
            return e.map
              ? e.map.queryRenderedFeatures(t, {
                  layers: [e.layerId],
                  filter: r
                })
              : null;
          };
        },
        getClusterExpansionZoom: function() {
          var e = this;
          return function(t) {
            return new Promise(function(r, n) {
              if (!e.mapSource)
                return n(
                  new Error(
                    "Map source with id ".concat(e.sourceId, " not found.")
                  )
                );
              e.mapSource.getClusterExpansionZoom(t, function(e, t) {
                return e ? n(e) : r(t);
              });
            });
          };
        },
        getClusterChildren: function() {
          var e = this;
          return function(t) {
            return new Promise(function(r, n) {
              var o = e.mapSource;
              if (!o)
                return n(
                  new Error(
                    "Map source with id ".concat(e.sourceId, " not found.")
                  )
                );
              o.getClusterChildren(t, function(e, t) {
                return e ? n(e) : r(t);
              });
            });
          };
        },
        getClusterLeaves: function() {
          var e = this;
          return function() {
            for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
              r[n] = arguments[n];
            return new Promise(function(t, n) {
              if (!e.mapSource)
                return n(
                  new Error(
                    "Map source with id ".concat(e.sourceId, " not found.")
                  )
                );
              var o;
              (o = e.mapSource).getClusterLeaves.apply(
                o,
                r.concat([
                  function(e, r) {
                    return e ? n(e) : t(r);
                  }
                ])
              );
            });
          };
        }
      },
      created: function() {
        this.source &&
          this.$watch(
            "source.data",
            function(e) {
              this.initial || this.mapSource.setData(e);
            },
            { deep: !0 }
          ),
          this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          if (
            (this.map.on("dataloading", this.$_watchSourceLoading), this.source)
          ) {
            var e = K({ type: "geojson" }, this.source);
            try {
              this.map.addSource(this.sourceId, e);
            } catch (t) {
              this.replaceSource &&
                (this.map.removeSource(this.sourceId),
                this.map.addSource(this.sourceId, e));
            }
          }
          this.$_addLayer(),
            this.$_bindLayerEvents(q),
            this.map.off("dataloading", this.$_watchSourceLoading),
            (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = K({ id: this.layerId, source: this.sourceId }, this.layer);
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        },
        setFeatureState: function(e, t) {
          if (this.map) {
            var r = { id: e, source: this.source };
            return this.map.setFeatureState(r, t);
          }
        },
        getFeatureState: function(e) {
          if (this.map) {
            var t = { id: e, source: this.source };
            return this.map.getFeatureState(t);
          }
        },
        removeFeatureState: function(e, t, r) {
          if (this.map) {
            var n = { id: e, source: this.source, sourceLayer: t };
            return this.map.removeFeatureState(n, r);
          }
        }
      }
    },
    ge = {
      name: "ImageLayer",
      mixins: [W],
      created: function() {
        this.source &&
          (this.source.coordinates &&
            this.$watch(
              "source.coordinates",
              function(e) {
                this.initial || (e && this.mapSource.setCoordinates(e));
              },
              { deep: !0 }
            ),
          this.source.url &&
            this.$watch(
              "source.url",
              function(e) {
                this.initial ||
                  (e &&
                    this.mapSource.updateImage({
                      url: e,
                      coordinates: this.source.coordinates
                    }));
              },
              { deep: !0 }
            )),
          this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = X({ type: "image" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(), this.$_bindLayerEvents(q), (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = X(
            { id: this.layerId, source: this.sourceId, type: "raster" },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        }
      }
    },
    Oe = {
      name: "CanvasLayer",
      mixins: [W],
      inject: ["mapbox", "map"],
      props: {
        source: { type: Object, required: !0 },
        layer: { type: Object, default: null }
      },
      computed: {
        canvasElement: function() {
          return this.mapSource ? this.mapSource.getCanvas() : null;
        }
      },
      watch: {
        coordinates: function(e) {
          this.initial || this.mapSource.setCoordinates(e);
        }
      },
      created: function() {
        this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = ee({ type: "canvas" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(), this.$_bindLayerEvents(q), (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = ee(
            { id: this.layerId, source: this.sourceId, type: "raster" },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", {
              layerId: this.layerId,
              canvas: this.canvasElement
            });
        }
      }
    },
    je = {
      name: "VideoLayer",
      mixins: [W],
      computed: {
        video: function() {
          return this.map.getSource(this.sourceId).getVideo();
        }
      },
      created: function() {
        this.source &&
          this.source.coordinates &&
          this.$watch("source.coordinates", function(e) {
            this.initial || this.mapSource.setCoordinates(e);
          }),
          this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = re({ type: "video" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(), this.$_bindLayerEvents(q), (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = re(
            { id: this.layerId, source: this.sourceId, type: "background" },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        }
      }
    },
    $e = {
      name: "VectorLayer",
      mixins: [W],
      computed: {
        getSourceFeatures: function() {
          var e = this;
          return function(t) {
            return e.map
              ? e.map.querySourceFeatures(e.sourceId, {
                  sourceLayer: e.layer["source-layer"],
                  filter: t
                })
              : null;
          };
        },
        getRenderedFeatures: function() {
          var e = this;
          return function(t, r) {
            return e.map
              ? e.map.queryRenderedFeatures(t, {
                  layers: [e.layerId],
                  filter: r
                })
              : null;
          };
        }
      },
      watch: {
        filter: function(e) {
          this.initial || this.map.setFilter(this.layerId, e);
        }
      },
      created: function() {
        this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = oe({ type: "vector" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(),
            this.$_bindLayerEvents(q),
            this.map.off("dataloading", this.$_watchSourceLoading),
            (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = oe({ id: this.layerId, source: this.sourceId }, this.layer);
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        },
        setFeatureState: function(e, t) {
          if (this.map) {
            var r = {
              id: e,
              source: this.sourceId,
              "source-layer": this.layer["source-layer"]
            };
            return this.map.setFeatureState(r, t);
          }
        },
        getFeatureState: function(e) {
          if (this.map) {
            var t = {
              id: e,
              source: this.source,
              "source-layer": this.layer["source-layer"]
            };
            return this.map.getFeatureState(t);
          }
        }
      }
    },
    Pe = {
      name: "RasterLayer",
      mixins: [W],
      created: function() {
        this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = ae({ type: "raster" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(),
            this.$_bindLayerEvents(q),
            this.map.off("dataloading", this.$_watchSourceLoading),
            (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = ae(
            { id: this.layerId, type: "raster", source: this.sourceId },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        }
      }
    },
    we = R,
    Se = N;
  (e.$helpers = le),
    (e.MglAttributionControl = ye),
    (e.MglCanvasLayer = Oe),
    (e.MglFullscreenControl = me),
    (e.MglGeojsonLayer = ve),
    (e.MglGeolocateControl = fe),
    (e.MglImageLayer = ge),
    (e.MglMap = de),
    (e.MglMarker = we),
    (e.MglNavigationControl = he),
    (e.MglPopup = Se),
    (e.MglRasterLayer = Pe),
    (e.MglScaleControl = be),
    (e.MglVectorLayer = $e),
    (e.MglVideoLayer = je),
    (e.asControl = ue),
    (e.asLayer = pe),
    (e.withEvents = se),
    (e.withSelfEvents = ce),
    Object.defineProperty(e, "__esModule", { value: !0 });
});
