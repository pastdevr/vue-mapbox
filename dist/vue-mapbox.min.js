import { h as e } from "vue";
import t from "map-promisified";
var a = {
    methods: {
      $_emitEvent(e, t = {}) {
        this.$emit(e, { map: this.map, component: this, ...t });
      },
      $_emitMapEvent(e, t = {}) {
        this.$_emitEvent(e.type, { mapboxEvent: e, ...t });
      }
    }
  },
  i = {
    resize: { name: "resize" },
    webglcontextlost: { name: "webglcontextlost" },
    webglcontextrestored: { name: "webglcontextrestored" },
    remove: { name: "remove" },
    movestart: { name: "movestart" },
    load: { name: "load" },
    contextmenu: { name: "contextmenu" },
    dblclick: { name: "dblclick" },
    click: { name: "click" },
    touchcancel: { name: "touchcancel" },
    touchmove: { name: "touchmove" },
    touchend: { name: "touchend" },
    touchstart: { name: "touchstart" },
    dataloading: { name: "dataloading" },
    mousemove: { name: "mousemove" },
    mouseup: { name: "mouseup" },
    mousedown: { name: "mousedown" },
    sourcedataloading: { name: "sourcedataloading" },
    error: { name: "error" },
    data: { name: "data" },
    styledata: { name: "styledata" },
    sourcedata: { name: "sourcedata" },
    mouseout: { name: "mouseout" },
    styledataloading: { name: "styledataloading" },
    moveend: { name: "moveend" },
    move: { name: "move" },
    render: { name: "render" },
    zoom: { name: "zoom" },
    zoomstart: { name: "zoomstart" },
    zoomend: { name: "zoomend" },
    boxzoomstart: { name: "boxzoomstart" },
    boxzoomcancel: { name: "boxzoomcancel" },
    boxzoomend: { name: "boxzoomend" },
    rotate: { name: "rotate" },
    rotatestart: { name: "rotatestart" },
    rotateend: { name: "rotateend" },
    dragend: { name: "dragend" },
    drag: { name: "drag" },
    dragstart: { name: "dragstart" },
    pitch: { name: "pitch" },
    idle: { name: "idle" }
  },
  r = {
    container: {
      type: [String, HTMLElement],
      default: () => "map-" + ("" + Math.random()).split(".")[1]
    },
    accessToken: { type: String, default: void 0 },
    minZoom: { type: Number, default: 0 },
    maxZoom: { type: Number, default: 22 },
    mapStyle: { type: [String, Object], required: !0 },
    hash: { type: [Boolean, String], default: !1 },
    interactive: { type: Boolean, default: !0 },
    bearingSnap: { type: Number, default: 7 },
    pitchWithRotate: { type: Boolean, default: !0 },
    clickTolerance: { type: Number, default: 3 },
    attributionControl: { type: Boolean, default: !0 },
    customAttribution: { type: [String, Array], default: null },
    logoPosition: {
      type: String,
      default: "bottom-left",
      validator: e =>
        ["top-left", "top-right", "bottom-left", "bottom-right"].includes(e)
    },
    failIfMajorPerformanceCaveat: { type: Boolean, default: !1 },
    preserveDrawingBuffer: { type: Boolean, default: !1 },
    refreshExpiredTiles: { type: Boolean, default: !0 },
    maxBounds: { type: Array, default() {} },
    scrollZoom: { type: [Boolean, Object], default: () => !0 },
    boxZoom: { type: Boolean, default: !0 },
    dragRotate: { type: Boolean, default: !0 },
    dragPan: { type: Boolean, default: !0 },
    keyboard: { type: Boolean, default: !0 },
    doubleClickZoom: { type: Boolean, default: !0 },
    touchZoomRotate: { type: [Boolean, Object], default: () => !0 },
    trackResize: { type: Boolean, default: !0 },
    center: { type: [Object, Array], default: void 0 },
    zoom: { type: Number, default: 0 },
    bearing: { type: Number, default: 0 },
    pitch: { type: Number, default: 0 },
    bounds: { type: [Object, Array], default: void 0 },
    fitBoundsOptions: { type: Object, default: void 0 },
    renderWorldCopies: { type: Boolean, default: !0 },
    RTLTextPluginUrl: { type: String, default: void 0 },
    light: { type: Object, default: void 0 },
    tileBoundaries: { type: Boolean, default: !1 },
    collisionBoxes: { type: Boolean, default: !1 },
    repaint: { type: Boolean, default: !1 },
    transformRequest: { type: Function, default: null },
    maxTileCacheSize: { type: Number, default: null },
    localIdeographFontFamily: { type: String, default: null },
    collectResourceTiming: { type: Boolean, default: !1 },
    fadeDuration: { type: Number, default: 300 },
    crossSourceCollisions: { type: Boolean, default: !0 }
  },
  s = e => {
    const t = /^on[^a-z]/,
      a = {};
    for (const i in e) t.test(i) && (a[i] = e[i]);
    return a;
  };
const o = {
  maxBounds(e) {
    this.map.setMaxBounds(e);
  },
  minZoom(e) {
    this.map.setMinZoom(e);
  },
  maxZoom(e) {
    this.map.setMaxZoom(e);
  },
  mapStyle(e) {
    this.map.setStyle(e);
  },
  collisionBoxes(e) {
    this.map.showCollisionBoxes = e;
  },
  tileBoundaries(e) {
    this.map.showTileBoundaries = e;
  },
  repaint(e) {
    this.map.repaint = e;
  },
  zoom(e) {
    this.map.setZoom(e);
  },
  center(e) {
    this.map.setCenter(e);
  },
  bearing(e) {
    this.map.setBearing(e);
  },
  pitch(e) {
    this.map.setPitch(e);
  },
  light(e) {
    this.map.setLigh(e);
  }
};
function n(e, t, a, i) {
  if (this.initial) return;
  s(this.$attrs)["update:" + e]
    ? (this.propsIsUpdating[e]
        ? ((this._watcher.active = !1),
          this.$nextTick(() => {
            this._watcher.active = !0;
          }))
        : ((this._watcher.active = !0), t(a, i)),
      (this.propsIsUpdating[e] = !1))
    : t(a, i);
}
var d = {
    name: "GlMap",
    mixins: [
      {
        watch: (function() {
          const e = {};
          return (
            Object.entries(o).forEach(t => {
              e[t[0]] = function(e, a) {
                return n.call(this, t[0], t[1].bind(this), e, a);
              };
            }),
            e
          );
        })()
      },
      {
        created() {
          this.actions = {};
        },
        methods: {
          $_registerAsyncActions(e) {
            this.actions = {
              ...t(e),
              stop() {
                this.map.stop();
                const e = {
                  pitch: this.map.getPitch(),
                  zoom: this.map.getZoom(),
                  bearing: this.map.getBearing(),
                  center: this.map.getCenter()
                };
                return (
                  Object.entries(e).forEach(e => {
                    this.$_updateSyncedPropsFabric(e[0], e[1])();
                  }),
                  Promise.resolve(e)
                );
              }
            };
          }
        }
      },
      {
        methods: {
          $_updateSyncedPropsFabric(e, t) {
            return () => {
              this.propsIsUpdating[e] = !0;
              let a = "function" == typeof t ? t() : t;
              return this.$emit("update:" + e, a);
            };
          },
          $_bindPropsUpdateEvents() {
            const e = [
                {
                  events: ["moveend"],
                  prop: "center",
                  getter: this.map.getCenter.bind(this.map)
                },
                {
                  events: ["zoomend"],
                  prop: "zoom",
                  getter: this.map.getZoom.bind(this.map)
                },
                {
                  events: ["rotate"],
                  prop: "bearing",
                  getter: this.map.getBearing.bind(this.map)
                },
                {
                  events: ["pitch"],
                  prop: "pitch",
                  getter: this.map.getPitch.bind(this.map)
                },
                {
                  events: ["moveend", "zoomend", "rotate", "pitch"],
                  prop: "bounds",
                  getter: () => {
                    let e = this.map.getBounds();
                    return (
                      this.$props.bounds instanceof Array && (e = e.toArray()),
                      e
                    );
                  }
                }
              ],
              t = s(this.$attrs);
            e.forEach(({ events: e, prop: a, getter: i }) => {
              e.forEach(e => {
                t["update:" + a] &&
                  this.map.on(e, this.$_updateSyncedPropsFabric(a, i));
              });
            });
          },
          $_loadMap() {
            return this.mapboxPromise.then(
              e => (
                (this.mapbox = e.default ? e.default : e),
                new Promise(e => {
                  this.accessToken &&
                    (this.mapbox.accessToken = this.accessToken);
                  const t = new this.mapbox.Map({
                    ...this._props,
                    container: this.$refs.container,
                    style: this.mapStyle
                  });
                  t.on("load", () => e(t));
                })
              )
            );
          },
          $_RTLTextPluginError(e) {
            this.$emit("rtl-plugin-error", { map: this.map, error: e });
          },
          $_bindMapEvents(e) {
            const t = s(this.$attrs);
            Object.keys(t).forEach(t => {
              e.includes(t) && this.map.on(t, this.$_emitMapEvent);
            });
          },
          $_unbindEvents(e) {
            e.forEach(e => {
              this.map.off(e, this.$_emitMapEvent);
            });
          }
        }
      },
      a
    ],
    props: { mapboxGl: { type: Object, default: null }, ...r },
    provide() {
      const e = this;
      return {
        get mapbox() {
          return e.mapbox;
        },
        get map() {
          return e.map;
        },
        get actions() {
          return e.actions;
        }
      };
    },
    data: () => ({ initial: !0, initialized: !1 }),
    computed: {
      loaded() {
        return !!this.map && this.map.loaded();
      },
      version() {
        return this.map ? this.map.version : null;
      },
      isStyleLoaded() {
        return !!this.map && this.map.isStyleLoaded();
      },
      areTilesLoaded() {
        return !!this.map && this.map.areTilesLoaded();
      },
      isMoving() {
        return !!this.map && this.map.isMoving();
      },
      canvas() {
        return this.map ? this.map.getCanvas() : null;
      },
      canvasContainer() {
        return this.map ? this.map.getCanvasContainer() : null;
      },
      images() {
        return this.map ? this.map.listImages() : null;
      }
    },
    created() {
      (this.map = null),
        (this.propsIsUpdating = {}),
        (this.$_containerVNode = null),
        (this.mapboxPromise = this.mapboxGl
          ? Promise.resolve(this.mapboxGl)
          : import("mapbox-gl"));
    },
    mounted() {
      this.$_loadMap().then(e => {
        (this.map = e),
          void 0 !== this.RTLTextPluginUrl &&
            "loaded" !== this.mapbox.getRTLTextPluginStatus() &&
            this.mapbox.setRTLTextPlugin(
              this.RTLTextPluginUrl,
              this.$_RTLTextPluginError
            );
        const t = Object.keys(i);
        this.$_bindMapEvents(t),
          this.$_registerAsyncActions(e),
          this.$_bindPropsUpdateEvents(),
          (this.initial = !1),
          (this.initialized = !0),
          this.$emit("load", { map: e, component: this });
      });
    },
    beforeDestroy() {
      this.$nextTick(() => {
        this.map && this.map.remove();
      });
    },
    render() {
      return (
        this.$$_containerVNode ||
          (this.$_containerVNode = e("div", {
            id: this.container,
            ref: "container"
          })),
        e("div", { class: "mgl-map-wrapper" }, [
          this.$_containerVNode,
          this.initialized ? this.$slots.default : null
        ])
      );
    }
  },
  h = {
    methods: {
      $_emitSelfEvent(e, t = {}) {
        this.$_emitMapEvent(e, { control: this.control, ...t });
      },
      $_bindSelfEvents(e, t) {
        const a = s(this.$attrs);
        Object.keys(a).forEach(a => {
          e.includes(a) && t.on(a, this.$_emitSelfEvent);
        });
      },
      $_unbindSelfEvents(e, t) {
        0 !== e.length &&
          t &&
          e.forEach(e => {
            t.off(e, this.$_emitSelfEvent);
          });
      }
    }
  },
  l = {
    mixins: [a, h],
    inject: ["mapbox", "map", "actions"],
    props: { position: { type: String, default: "top-right" } },
    beforeDestroy() {
      this.map && this.control && this.map.removeControl(this.control);
    },
    methods: {
      $_addControl() {
        try {
          this.map.addControl(this.control, this.position);
        } catch (e) {
          return void this.$_emitEvent("error", { error: e });
        }
        this.$_emitEvent("added", { control: this.control });
      }
    },
    render() {}
  },
  p = {
    name: "NavigationControl",
    mixins: [l],
    props: {
      showCompass: { type: Boolean, default: !0 },
      showZoom: { type: Boolean, default: !0 }
    },
    created() {
      (this.control = new this.mapbox.NavigationControl(this.$props)),
        this.$_addControl();
    }
  };
const m = {
  trackuserlocationstart: "trackuserlocationstart",
  trackuserlocationend: "trackuserlocationend",
  geolocate: "geolocate",
  error: "error"
};
var u = {
    name: "GeolocateControl",
    mixins: [a, h, l],
    props: {
      positionOptions: {
        type: Object,
        default: () => ({ enableHighAccuracy: !1, timeout: 6e3 })
      },
      fitBoundsOptions: { type: Object, default: () => ({ maxZoom: 15 }) },
      trackUserLocation: { type: Boolean, default: !1 },
      showUserLocation: { type: Boolean, default: !0 }
    },
    created() {
      const e = this.mapbox.GeolocateControl;
      (this.control = new e(this.$props)),
        this.$_addControl(),
        this.$_bindSelfEvents(Object.keys(m), this.control);
    },
    methods: {
      trigger() {
        if (this.control) return this.control.trigger();
      }
    }
  },
  c = {
    name: "FullscreenControl",
    mixins: [l],
    props: { container: { type: HTMLElement, default: void 0 } },
    created() {
      (this.control = new this.mapbox.FullscreenControl(this.$props)),
        this.$_addControl();
    }
  },
  y = {
    name: "AttributionControl",
    mixins: [l],
    props: {
      compact: { type: Boolean, default: !0 },
      customAttribution: { type: [String, Array], deafault: void 0 }
    },
    created() {
      (this.control = new this.mapbox.AttributionControl(this.$props)),
        this.$_addControl();
    }
  };
const f = { drag: "drag", dragstart: "dragstart", dragend: "dragend" },
  g = { click: "click", mouseenter: "mouseenter", mouseleave: "mouseleave" };
var v = {
  name: "MapMarker",
  mixins: [a, h],
  inject: ["mapbox", "map"],
  provide() {
    const e = this;
    return {
      get marker() {
        return e.marker;
      }
    };
  },
  props: {
    offset: { type: [Object, Array], default: () => [0, 0] },
    coordinates: { type: Array, required: !0 },
    color: { type: String },
    anchor: { type: String, default: "center" },
    draggable: { type: Boolean, default: !1 }
  },
  data: () => ({ initial: !0, marker: void 0 }),
  watch: {
    coordinates(e) {
      this.initial || this.marker.setLngLat(e);
    },
    draggable(e) {
      this.initial || this.marker.setDraggable(e);
    }
  },
  mounted() {
    const e = { ...this.$props };
    this.$slots.marker && (e.element = this.$slots.marker[0].elm),
      (this.marker = new this.mapbox.Marker(e));
    s(this.$attrs)["update:coordinates"] &&
      this.marker.on("dragend", e => {
        let t;
        (t =
          this.coordinates instanceof Array
            ? [e.target._lngLat.lng, e.target._lngLat.lat]
            : e.target._lngLat),
          this.$emit("update:coordinates", t);
      });
    const t = Object.keys(f);
    this.$_bindSelfEvents(t, this.marker),
      (this.initial = !1),
      this.$_addMarker();
  },
  beforeDestroy() {
    void 0 !== this.map && void 0 !== this.marker && this.marker.remove();
  },
  methods: {
    $_addMarker() {
      this.marker.setLngLat(this.coordinates).addTo(this.map),
        this.$_bindMarkerDOMEvents(),
        this.$_emitEvent("added", { marker: this.marker });
    },
    $_emitSelfEvent(e) {
      this.$_emitMapEvent(e, { marker: this.marker });
    },
    $_bindMarkerDOMEvents() {
      const e = s(this.$attrs);
      Object.keys(e).forEach(e => {
        Object.values(g).includes(e) &&
          this.marker._element.addEventListener(e, e => {
            this.$_emitSelfEvent(e);
          });
      });
    },
    remove() {
      this.marker.remove(), this.$_emitEvent("removed");
    },
    togglePopup() {
      return this.marker.togglePopup();
    }
  },
  render() {
    return e("div", { style: { display: "none" } }, [
      this.$slots.marker,
      this.marker ? this.$slots.default : null
    ]);
  }
};
const $ = { open: "open", close: "close" };
var b = {
    name: "Popup",
    mixins: [a, h],
    inject: {
      mapbox: { default: null },
      map: { default: null },
      marker: { default: null }
    },
    props: {
      closeButton: { type: Boolean, default: !0 },
      closeOnClick: { type: Boolean, default: !0 },
      anchor: {
        validator: e =>
          "string" == typeof e &&
          [
            "top",
            "bottom",
            "left",
            "right",
            "top-left",
            "top-right",
            "bottom-left",
            "bottom-right"
          ].includes(e),
        default: void 0
      },
      offset: { type: [Number, Object, Array], default: () => [0, 0] },
      coordinates: { type: Array },
      onlyText: { type: Boolean, default: !1 },
      showed: { type: Boolean, default: !1 }
    },
    data: () => ({ initial: !0, popup: void 0 }),
    computed: {
      open: {
        get() {
          return void 0 !== this.popup && this.popup.isOpen();
        },
        set(e) {
          this.map &&
            this.popup &&
            (e ? this.popup.addTo(this.map) : this.popup.remove());
        }
      }
    },
    watch: {
      coordinates(e) {
        this.initial || this.popup.setLngLat(e);
      },
      showed(e, t) {
        e !== t && ((this.open = e), this.marker && this.marker.togglePopup());
      }
    },
    created() {
      this.popup = new this.mapbox.Popup(this.$props);
    },
    mounted() {
      this.$_addPopup(), (this.initial = !1);
    },
    beforeDestroy() {
      this.map && (this.popup.remove(), this.$_emitEvent("removed"));
    },
    methods: {
      $_addPopup() {
        if (
          ((this.popup = new this.mapbox.Popup(this.$props)),
          void 0 !== this.coordinates && this.popup.setLngLat(this.coordinates),
          void 0 !== this.$slots.default)
        )
          if (this.onlyText)
            if (3 === this.$slots.default[0].elm.nodeType) {
              let e = document.createElement("span");
              e.appendChild(this.$slots.default[0].elm),
                this.popup.setText(e.innerText);
            } else this.popup.setText(this.$slots.default[0].elm.innerText);
          else this.popup.setDOMContent(this.$slots.default[0].elm);
        this.$_bindSelfEvents(Object.keys($), this.popup),
          this.$_emitEvent("added", { popup: this.popup }),
          this.marker && this.marker.setPopup(this.popup),
          this.showed &&
            ((this.open = !0), this.marker && this.marker.togglePopup());
      },
      $_emitSelfEvent(e) {
        this.$_emitMapEvent(e, { popup: this.popup });
      },
      remove() {
        this.popup.remove(), this.$_emitEvent("remove", { popup: this.popup });
      }
    },
    render() {
      return e("div", { style: { display: "none" } }, [this.$slots.default]);
    }
  },
  _ = [
    "mousedown",
    "mouseup",
    "click",
    "dblclick",
    "mousemove",
    "mouseenter",
    "mouseleave",
    "mouseover",
    "mouseout",
    "contextmenu",
    "touchstart",
    "touchend",
    "touchcancel"
  ];
var I = {
  mixins: [a],
  props: {
    ...{
      sourceId: { type: String, required: !0 },
      source: { type: [Object, String], default: void 0 }
    },
    ...{
      layerId: { type: String, required: !0 },
      layer: { type: Object, required: !0 },
      before: { type: String, default: void 0 }
    },
    ...{
      clearSource: { type: Boolean, default: !0 },
      replaceSource: { type: Boolean, default: !1 },
      replace: { type: Boolean, default: !1 }
    }
  },
  inject: ["mapbox", "map"],
  data: () => ({ initial: !0 }),
  computed: {
    sourceLoaded() {
      return !!this.map && this.map.isSourceLoaded(this.sourceId);
    },
    mapLayer() {
      return this.map ? this.map.getLayer(this.layerId) : null;
    },
    mapSource() {
      return this.map ? this.map.getSource(this.sourceId) : null;
    }
  },
  created() {
    this.layer.minzoom &&
      this.$watch("layer.minzoom", function(e) {
        this.initial ||
          this.map.setLayerZoomRange(this.layerId, e, this.layer.maxzoom);
      }),
      this.layer.maxzoom &&
        this.$watch("layer.maxzoom", function(e) {
          this.initial ||
            this.map.setLayerZoomRange(this.layerId, this.layer.minzoom, e);
        }),
      this.layer.paint &&
        this.$watch(
          "layer.paint",
          function(e) {
            if (!this.initial && e)
              for (let t of Object.keys(e))
                this.map.setPaintProperty(this.layerId, t, e[t]);
          },
          { deep: !0 }
        ),
      this.layer.layout &&
        this.$watch(
          "layer.layout",
          function(e) {
            if (!this.initial && e)
              for (let t of Object.keys(e))
                this.map.setLayoutProperty(this.layerId, t, e[t]);
          },
          { deep: !0 }
        ),
      this.layer.filter &&
        this.$watch(
          "layer.filter",
          function(e) {
            this.initial || this.map.setFilter(this.layerId, e);
          },
          { deep: !0 }
        );
  },
  beforeDestroy() {
    if (this.map && this.map.loaded()) {
      try {
        this.map.removeLayer(this.layerId);
      } catch (e) {
        this.$_emitEvent("layer-does-not-exist", {
          layerId: this.sourceId,
          error: e
        });
      }
      if (this.clearSource)
        try {
          this.map.removeSource(this.sourceId);
        } catch (e) {
          this.$_emitEvent("source-does-not-exist", {
            sourceId: this.sourceId,
            error: e
          });
        }
    }
  },
  methods: {
    $_emitLayerMapEvent(e) {
      return this.$_emitMapEvent(e, { layerId: this.layerId });
    },
    $_bindLayerEvents(e) {
      const t = s(this.$attrs);
      Object.keys(t).forEach(t => {
        e.includes(t) && this.map.on(t, this.layerId, this.$_emitLayerMapEvent);
      });
    },
    $_unbindEvents(e) {
      this.map &&
        e.forEach(e => {
          this.map.off(e, this.layerId, this.$_emitLayerMapEvent);
        });
    },
    $_watchSourceLoading(e) {
      "source" === e.dataType &&
        e.sourceId === this.sourceId &&
        (this.$_emitEvent("layer-source-loading", { sourceId: this.sourceId }),
        this.map.off("dataloading", this.$_watchSourceLoading));
    },
    move(e) {
      this.map.moveLayer(this.layerId, e),
        this.$_emitEvent("layer-moved", { layerId: this.layerId, beforeId: e });
    },
    remove() {
      this.map.removeLayer(this.layerId),
        this.map.removeSource(this.sourceId),
        this.$_emitEvent("layer-removed", { layerId: this.layerId }),
        this.$destroy();
    }
  },
  render() {}
};
const S = a,
  L = h,
  x = l,
  E = I,
  k = { withEvents: a, withSelfEvents: h, asControl: l, asLayer: I },
  w = d,
  B = p,
  C = u,
  M = c,
  P = y,
  T = {
    name: "ScaleControl",
    mixins: [l],
    props: {
      maxWidth: { type: Number, default: 150 },
      unit: {
        type: String,
        default: "metric",
        validator: e => ["imperial", "metric", "nautical"].includes(e)
      }
    },
    watch: {
      unit(e, t) {
        this.control && e !== t && this.control.setUnit(e);
      }
    },
    created() {
      (this.control = new this.mapbox.ScaleControl(this.$props)),
        this.$_addControl();
    }
  },
  j = {
    name: "GeojsonLayer",
    mixins: [I],
    computed: {
      getSourceFeatures() {
        return e =>
          this.map
            ? this.map.querySourceFeatures(this.sourceId, { filter: e })
            : null;
      },
      getRenderedFeatures() {
        return (e, t) =>
          this.map
            ? this.map.queryRenderedFeatures(e, {
                layers: [this.layerId],
                filter: t
              })
            : null;
      },
      getClusterExpansionZoom() {
        return e =>
          new Promise((t, a) => {
            if (!this.mapSource)
              return a(
                new Error(`Map source with id ${this.sourceId} not found.`)
              );
            this.mapSource.getClusterExpansionZoom(e, (e, i) =>
              e ? a(e) : t(i)
            );
          });
      },
      getClusterChildren() {
        return e =>
          new Promise((t, a) => {
            const i = this.mapSource;
            if (!i)
              return a(
                new Error(`Map source with id ${this.sourceId} not found.`)
              );
            i.getClusterChildren(e, (e, i) => (e ? a(e) : t(i)));
          });
      },
      getClusterLeaves() {
        return (...e) =>
          new Promise((t, a) => {
            if (!this.mapSource)
              return a(
                new Error(`Map source with id ${this.sourceId} not found.`)
              );
            this.mapSource.getClusterLeaves(...e, (e, i) => (e ? a(e) : t(i)));
          });
      }
    },
    created() {
      this.source &&
        this.$watch(
          "source.data",
          function(e) {
            this.initial || this.mapSource.setData(e);
          },
          { deep: !0 }
        ),
        this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        if (
          (this.map.on("dataloading", this.$_watchSourceLoading), this.source)
        ) {
          const e = { type: "geojson", ...this.source };
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
        }
        this.$_addLayer(),
          this.$_bindLayerEvents(_),
          this.map.off("dataloading", this.$_watchSourceLoading),
          (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        const t = { id: this.layerId, source: this.sourceId, ...this.layer };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      },
      setFeatureState(e, t) {
        if (this.map) {
          const a = { id: e, source: this.source };
          return this.map.setFeatureState(a, t);
        }
      },
      getFeatureState(e) {
        if (this.map) {
          const t = { id: e, source: this.source };
          return this.map.getFeatureState(t);
        }
      },
      removeFeatureState(e, t, a) {
        if (this.map) {
          const i = { id: e, source: this.source, sourceLayer: t };
          return this.map.removeFeatureState(i, a);
        }
      }
    }
  },
  O = {
    name: "ImageLayer",
    mixins: [I],
    created() {
      this.source &&
        (this.source.coordinates &&
          this.$watch(
            "source.coordinates",
            function(e) {
              this.initial || (e && this.mapSource.setCoordinates(e));
            },
            { deep: !0 }
          ),
        this.source.url &&
          this.$watch(
            "source.url",
            function(e) {
              this.initial ||
                (e &&
                  this.mapSource.updateImage({
                    url: e,
                    coordinates: this.source.coordinates
                  }));
            },
            { deep: !0 }
          )),
        this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        const e = { type: "image", ...this.source };
        this.map.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.removeSource(this.sourceId),
            this.map.addSource(this.sourceId, e));
        }
        this.$_addLayer(), this.$_bindLayerEvents(_), (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        const t = {
          id: this.layerId,
          source: this.sourceId,
          type: "raster",
          ...this.layer
        };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      }
    }
  },
  z = {
    name: "CanvasLayer",
    mixins: [I],
    inject: ["mapbox", "map"],
    props: {
      source: { type: Object, required: !0 },
      layer: { type: Object, default: null }
    },
    computed: {
      canvasElement() {
        return this.mapSource ? this.mapSource.getCanvas() : null;
      }
    },
    watch: {
      coordinates(e) {
        this.initial || this.mapSource.setCoordinates(e);
      }
    },
    created() {
      this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        const e = { type: "canvas", ...this.source };
        this.map.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.removeSource(this.sourceId),
            this.map.addSource(this.sourceId, e));
        }
        this.$_addLayer(), this.$_bindLayerEvents(_), (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        let t = {
          id: this.layerId,
          source: this.sourceId,
          type: "raster",
          ...this.layer
        };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", {
            layerId: this.layerId,
            canvas: this.canvasElement
          });
      }
    }
  },
  F = {
    name: "VideoLayer",
    mixins: [I],
    computed: {
      video() {
        return this.map.getSource(this.sourceId).getVideo();
      }
    },
    created() {
      this.source &&
        this.source.coordinates &&
        this.$watch("source.coordinates", function(e) {
          this.initial || this.mapSource.setCoordinates(e);
        }),
        this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        const e = { type: "video", ...this.source };
        this.map.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.removeSource(this.sourceId),
            this.map.addSource(this.sourceId, e));
        }
        this.$_addLayer(), this.$_bindLayerEvents(_), (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        let t = {
          id: this.layerId,
          source: this.sourceId,
          type: "background",
          ...this.layer
        };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      }
    }
  },
  A = {
    name: "VectorLayer",
    mixins: [I],
    computed: {
      getSourceFeatures() {
        return e =>
          this.map
            ? this.map.querySourceFeatures(this.sourceId, {
                sourceLayer: this.layer["source-layer"],
                filter: e
              })
            : null;
      },
      getRenderedFeatures() {
        return (e, t) =>
          this.map
            ? this.map.queryRenderedFeatures(e, {
                layers: [this.layerId],
                filter: t
              })
            : null;
      }
    },
    watch: {
      filter(e) {
        this.initial || this.map.setFilter(this.layerId, e);
      }
    },
    created() {
      this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        let e = { type: "vector", ...this.source };
        this.map.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.removeSource(this.sourceId),
            this.map.addSource(this.sourceId, e));
        }
        this.$_addLayer(),
          this.$_bindLayerEvents(_),
          this.map.off("dataloading", this.$_watchSourceLoading),
          (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        let t = { id: this.layerId, source: this.sourceId, ...this.layer };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      },
      setFeatureState(e, t) {
        if (this.map) {
          const a = {
            id: e,
            source: this.sourceId,
            "source-layer": this.layer["source-layer"]
          };
          return this.map.setFeatureState(a, t);
        }
      },
      getFeatureState(e) {
        if (this.map) {
          const t = {
            id: e,
            source: this.source,
            "source-layer": this.layer["source-layer"]
          };
          return this.map.getFeatureState(t);
        }
      }
    }
  },
  R = {
    name: "RasterLayer",
    mixins: [I],
    created() {
      this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        let e = { type: "raster", ...this.source };
        this.map.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.removeSource(this.sourceId),
            this.map.addSource(this.sourceId, e));
        }
        this.$_addLayer(),
          this.$_bindLayerEvents(_),
          this.map.off("dataloading", this.$_watchSourceLoading),
          (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        let t = {
          id: this.layerId,
          type: "raster",
          source: this.sourceId,
          ...this.layer
        };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      }
    }
  },
  Z = v,
  N = b;
export {
  k as $helpers,
  P as MglAttributionControl,
  z as MglCanvasLayer,
  M as MglFullscreenControl,
  j as MglGeojsonLayer,
  C as MglGeolocateControl,
  O as MglImageLayer,
  w as MglMap,
  Z as MglMarker,
  B as MglNavigationControl,
  N as MglPopup,
  R as MglRasterLayer,
  T as MglScaleControl,
  A as MglVectorLayer,
  F as MglVideoLayer,
  x as asControl,
  E as asLayer,
  S as withEvents,
  L as withSelfEvents
};
